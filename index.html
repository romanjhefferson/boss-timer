<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Lordnine Boss Monitoring - Enhanced</title>
<style>
/* ==== Global Styles ==== */
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: #0f0f0f; color: #e0e0e0; }
header { background: linear-gradient(90deg,#2b0033,#0a0a0a); padding: 1rem; text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.8); border-bottom: 1px solid #550066; }
#nextRespawn{ font-size:1.3rem; font-weight:bold; text-shadow:0 0 8px #ff00ff; }
button#themeToggle{ position:absolute; right:1rem; top:1rem; background:#1a1a1a; border:1px solid #550066; color:#e0e0e0; border-radius:8px; padding:6px 12px; cursor:pointer; }
h3 { padding-left:1rem; margin-top:2rem; color:#ff4dff; text-shadow:0 0 6px #aa00ff; letter-spacing:1px; }
.separator{ text-align:center; margin:1rem 0; opacity:0.7; }

/* ==== Table Style (Gaming Theme) ==== */
table { width:95%; margin:1rem auto; border-collapse:collapse; background:#1a1a1a; border:1px solid #330044; box-shadow:0 0 10px rgba(255,0,255,0.1); border-radius:8px; overflow:hidden; }
th { background:#3b0044; text-align:left; padding:10px; text-transform:uppercase; font-size:0.85rem; color:#ff99ff; border-bottom:2px solid #550066; }
td { padding:10px; border-bottom:1px solid #2b002f; }
tr:hover { background:#2a002e; transition:0.2s; }

/* ==== Status Highlights ==== */
.status-soon{ color:#ffcc00; font-weight:bold; }
.status-verysoon{ color:#ff4d4d; font-weight:bold; text-shadow:0 0 6px #ff0000; }
.status-today{ color:#66ccff; font-weight:bold; }
.row-soon{ background:rgba(255,204,0,0.08); }
.row-verysoon{ background:rgba(255,0,0,0.08); }
.row-alive{ background:rgba(0,255,0,0.1); }

/* Banner urgency colors */
#nextRespawn.soon{ color:#ffcc00; }
#nextRespawn.verysoon{ color:#ff4d4d; }
#nextRespawn.today{ color:#66ccff; }
</style>
</head>
<body>
<header>
  <div id="respawnBanner"><span id="nextRespawn">Loading...</span></div>
  <button id="themeToggle">üåô</button>
</header>
<h3>‚öî Dynamic Respawns</h3>
<table id="upcoming"><thead><tr><th>Boss</th><th>Status</th><th>Respawn Time</th><th>Countdown</th></tr></thead><tbody></tbody></table>
<h3>üü¢ Currently Alive</h3>
<table id="alive"><thead><tr><th>Boss</th><th>Status</th><th>Death Time</th><th>Respawn Time</th></tr></thead><tbody></tbody></table>
<h3>‚è≥ Fixed Respawns</h3>
<table id="fixed"><thead><tr><th>Boss</th><th>Status</th><th>Respawn Time</th><th>Countdown</th></tr></thead><tbody></tbody></table>
<script>
const sheetURL = "https://opensheet.elk.sh/1RoupDDa_fQdcowVCNpL2q1mJDDAw3obvIwRQhOp7Z5E/Sheet1";

const respawnTimes = { 
  "Venatus": 10, "Viorent": 10, "Araneo": 24, "Undomiel": 24,
  "Lady Dalia": 18, "Amentis": 29, "Ego": 21, "Livera": 24,
  "General Aquleus": 29, "Baron Braudmore": 32, "Wannitas": 48,
  "Metus": 48, "Duplican": 48, "Shuliar": 35, "Gareth": 32,
  "Titore": 37, "Larba": 35,
  "Catena": 35,
  "Secreta": 62,
  "Ordo": 62,
  "Asta": 62,
  "Supore": 62
};

const fixedSchedules = {
  "Clemantis": [ { day: 1, hour: 11, minute: 30 }, { day: 4, hour: 19, minute: 0 } ],
  "Saphirus": [ { day: 2, hour: 11, minute: 30 }, { day: 0, hour: 17, minute: 0 } ],
  "Neutro":   [ { day: 2, hour: 19, minute: 0 }, { day: 4, hour: 11, minute: 30 } ],
  "Milavy":   [ { day: 6, hour: 15, minute: 0 } ],
  "Ringor":   [ { day: 6, hour: 17, minute: 0 } ],
  "Roderick": [ { day: 5, hour: 19, minute: 0 } ],
  "Thymele":  [ { day: 1, hour: 19, minute: 0 }, { day: 3, hour: 11, minute: 30 } ],
  "Auraq":    [ { day: 3, hour: 21, minute: 0 }, { day: 5, hour: 22, minute: 0 } ],
  "Chaiflock": [ { day: 6, hour: 22, minute: 0 } ],
  "Benji": [ { day: 0, hour: 21, minute: 0 } ]
};

function formatDate(date) {
  const options = { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true };
  return date.toLocaleString('en-US', options);
}
function formatDateWithWeekday(date) {
  const weekday = date.toLocaleDateString('en-US', { weekday: 'short' });
  return `${formatDate(date)} (${weekday})`;
}
function formatCountdown(target) {
  const now = new Date();
  const diff = target - now;
  if (diff <= 0) return "Now!";
  const h = Math.floor(diff / (1000*60*60));
  const m = Math.floor((diff % (1000*60*60)) / (1000*60));
  const s = Math.floor((diff % (1000*60)) / 1000);

  const today = now.toDateString();
  const tomorrow = new Date(now); tomorrow.setDate(now.getDate() + 1);
  const targetDay = target.toDateString();

  if (targetDay === today) return `Today, ${h}h ${m}m ${s}s`;
  if (targetDay === tomorrow.toDateString()) return `Tomorrow, ${h}h ${m}m ${s}s`;
  return `${h}h ${m}m ${s}s`;
}

let bossData = [];
let bannerInterval = null;
let countdownInterval = null;

async function fetchData() {
  try {
    const res = await fetch(sheetURL);
    const data = await res.json();
    bossData = data;
    render();
  } catch (err) {
    console.error('Failed to fetch sheet:', err);
    document.getElementById('nextRespawn').textContent = 'Failed to load data';
  }
}

function computeDynamic(now) {
  const upcoming = [];
  const alive = [];

  (bossData || []).forEach(row => {
    const boss = (row.Boss || '').trim();
    const deathTime = new Date(row.DeathTime);
    const hours = respawnTimes[boss];
    if (!hours || !deathTime || isNaN(deathTime)) return;

    const respawn = new Date(deathTime.getTime() + hours * 60 * 60 * 1000);
    const diffMs = respawn - now;
    const diffH = diffMs / (1000*60*60);

    let status = '‚è≥ Upcoming', rowClass = '', statusClass = '', countdownClass = '';
    if (diffMs > 0) {
      if (diffH < 1) {
        status = 'üî¥ Very Soon'; rowClass = 'row-verysoon'; statusClass = 'status-verysoon'; countdownClass = 'countdown-verysoon';
      } else if (diffH < 6) {
        status = 'üü° Soon'; rowClass = 'row-soon'; statusClass = 'status-soon'; countdownClass = 'countdown-soon';
      }
      upcoming.push({ boss, status, statusClass, countdownClass, respawn, rowClass });
    } else {
      status = 'üü¢ Alive'; rowClass = 'row-alive';
      alive.push({ boss, status, deathTime, respawn, rowClass });
    }
  });

  upcoming.sort((a,b)=>a.respawn-b.respawn);
  alive.sort((a,b)=>a.respawn-b.respawn);
  return { upcoming, alive };
}

function computeFixed(now) {
  const fixedUpcoming = [];

  Object.entries(fixedSchedules).forEach(([boss, schedules]) => {
    schedules.forEach(s => {
      const respawn = new Date(now);
      respawn.setDate(now.getDate() + ((s.day - now.getDay() + 7) % 7));
      respawn.setHours(s.hour, s.minute, 0, 0);
      if (respawn < now) respawn.setDate(respawn.getDate() + 7);

      const diffMs = respawn - now;
      const diffH = diffMs / (1000*60*60);

      let status = '‚è≥ Scheduled', rowClass = '', statusClass = '', countdownClass = '';
      const soon = respawn.toDateString() === now.toDateString();
      if (diffMs > 0 && diffH < 1) {
        status = 'üî¥ Very Soon'; rowClass = 'row-verysoon'; statusClass = 'status-verysoon'; countdownClass = 'countdown-verysoon';
      } else if (diffMs > 0 && diffH < 6) {
        status = 'üü° Soon'; rowClass = 'row-soon'; statusClass = 'status-soon'; countdownClass = 'countdown-soon';
      } else if (soon) {
        status = '‚ö° Today'; statusClass = 'status-today'; countdownClass = 'countdown-today';
      }

      fixedUpcoming.push({ boss, status, statusClass, countdownClass, respawn, rowClass, soon });
    });
  });

  fixedUpcoming.sort((a,b)=>a.respawn-b.respawn);
  return fixedUpcoming;
}

function render() {
  const now = new Date();
  const { upcoming, alive } = computeDynamic(now);
  const fixedUpcoming = computeFixed(now);

  document.querySelector('#upcoming tbody').innerHTML = upcoming.map(r =>
    `<tr class="${r.rowClass}"><td>${r.boss}</td><td class="${r.statusClass}">${r.status}</td><td>${formatDateWithWeekday(r.respawn)}</td><td class="countdown ${r.countdownClass}" data-time="${r.respawn}">${formatCountdown(r.respawn)}</td></tr>`
  ).join('') || '<tr><td colspan="4" style="padding:12px;">No upcoming dynamic respawns</td></tr>';

  document.querySelector('#alive tbody').innerHTML = alive.map(r =>
    `<tr class="${r.rowClass}"><td>${r.boss}</td><td>${r.status}</td><td>${formatDateWithWeekday(r.deathTime)}</td><td>${formatDateWithWeekday(r.respawn)}</td></tr>`
  ).join('') || '<tr><td colspan="4" style="padding:12px;">No bosses currently alive</td></tr>';

  document.querySelector('#fixed tbody').innerHTML = fixedUpcoming.map(r =>
    `<tr class="${r.rowClass}"><td>${r.boss}</td><td class="${r.statusClass}">${r.status}</td><td>${formatDateWithWeekday(r.respawn)}</td><td class="countdown ${r.countdownClass}" data-time="${r.respawn}">${formatCountdown(r.respawn)}</td></tr>`
  ).join('') || '<tr><td colspan="4" style="padding:12px;">No fixed respawns configured</td></tr>';

  const allUpcoming = [...upcoming, ...fixedUpcoming].filter(x=>x && x.respawn).sort((a,b)=>a.respawn-b.respawn);
  const banner = document.getElementById('nextRespawn');

  if (allUpcoming.length) {
    const soonest = allUpcoming[0];

    function updateBanner() {
      const nowU = new Date();
      const diff = soonest.respawn - nowU;
      const h = Math.floor(diff / (1000*60*60));
      const m = Math.floor((diff % (1000*60*60)) / (1000*60));
      const s = Math.floor((diff % (1000*60)) / 1000);
      banner.textContent = `${soonest.boss} respawns in ${h}h ${m}m ${s}s at ${formatDateWithWeekday(soonest.respawn)}`;

      let urgency = '';
      if (soonest.statusClass && soonest.statusClass.includes('verysoon')) urgency = 'verysoon';
      else if (soonest.statusClass && soonest.statusClass.includes('soon')) urgency = 'soon';
      else if (soonest.statusClass && soonest.statusClass.includes('today')) urgency = 'today';

      banner.className = urgency;

      document.querySelectorAll('.countdown').forEach(td => {
        const t = new Date(td.dataset.time);
        td.textContent = formatCountdown(t);
      });

      if (diff <= 0) {
        fetchData();
      }
    }

    if (bannerInterval) clearInterval(bannerInterval);
    updateBanner();
    bannerInterval = setInterval(updateBanner, 1000);
  } else {
    banner.textContent = 'No upcoming respawns';
    banner.className = '';
    if (bannerInterval) clearInterval(bannerInterval);
  }

  if (countdownInterval) clearInterval(countdownInterval);
  countdownInterval = setInterval(()=>{
    document.querySelectorAll('.countdown').forEach(td => {
      const t = new Date(td.dataset.time);
      td.textContent = formatCountdown(t);
    });
  },1000);
}

fetchData();
setInterval(fetchData, 60 * 1000);

const themeToggleBtn = document.getElementById('themeToggle');
(function setDefaultTheme(){
  document.body.style.background = '#0f0f0f';
  document.body.style.color = '#e0e0e0';
})();

themeToggleBtn.addEventListener('click', () => {
  if (document.body.dataset.theme === 'light') {
    document.body.dataset.theme = 'dark';
    document.body.style.background = '#0f0f0f';
    document.body.style.color = '#e0e0e0';
    themeToggleBtn.textContent = 'üåô';
  } else {
    document.body.dataset.theme = 'light';
    document.body.style.background = '#f6f6f6';
    document.body.style.color = '#111';
    themeToggleBtn.textContent = '‚òÄÔ∏è';
  }
});
</script>
</body>
</html>
